#+TITLE:  README
#+AUTHOR: Yang,Ying-chao
#+DATE:   2024-07-02
#+OPTIONS:  ^:nil H:5 num:t toc:2 \n:nil ::t |:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+STARTUP:  align nodlcheck oddeven lognotestate
#+SEQ_TODO: TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+LANGUAGE: en
#+TAGS:     noexport(n)
#+EXCLUDE_TAGS: noexport
#+FILETAGS: :tag1:tag2:

I wrote some functions with elisp to help me analyze core dumps & call stacks. I think they are very
helpful, so I've decided to rewrite them in Rust, making them usable outside of Emacs.

#+begin_src sh -r :results verbatim :exports both
./target/debug/cs --help
#+end_src

#+RESULTS:
#+begin_example
Tool to show call stack of process(es)

Usage: cs [OPTIONS]

Options:
  -p, --pid <PIDS>               Show stack of process PID
  -c, --core <CORE>              Show stack found in COREFILE
  -e, --executable <EXECUTABLE>  (optional) EXECUTABLE that produced COREFILE
  -u, --users <USERS>            Show processes of users(separated by ","), effective when listing and choosing processes
  -l, --list [<LIST>]            List processes
  -i, --initial <INITIAL>        Initial value to filter process
  -f, --file <FILE>              read call stacks from file
  -s, --stdin                    read call stacks from file
  -W, --Wide                     Wide mode: when showing processes, show all chars in a line
  -M, --multi                    Multi mode: when choosing processes, to select multiple processes
  -U, --unique                   Unique mode: when showing call stack, show only unique ones
  -G, --gdb                      gdb mode: use gdb to get call stack (default to eu-stack)
  -R, --raw                      Row mode: do not try to simpilfy callstacks (works only in GDB mode)
  -h, --help                     Print help
  -V, --version                  Print version
#+end_example


+ TODO
  - [ ] highlight suspicious lines (signal, crash, deadlock...) \\
    #+begin_src emacs-lisp -r
      (defun yc/stack-suspicious-p (stack)
        "Check if STACK is suspicious."
        (let ((r-match-suspicious
               (rx (+? ascii) (or "segfault" "segmentfault""segment fault" "signal handler called" "raise"
                                  "__assert_fail" (: bow "abort" eow))
                   (? space) (? "()") (+? ascii)))
              (r-match-line (rx "#" (* space) (+ digit) (+ space) (group "0x" (+ hex))
                                (+ space) (group (+? nonl)) eol))
              (r-match-lock (rx (or "_L_lock_" "__lll_lock_"))))

          (or (s-matches-p r-match-suspicious stack)
              ;; if top frame is waiting lock, and same frames appear multiple
              ;; times, this might be a dead lock
              (pcase-let ((`(,_ ,pos ,addr ,name) (s-match r-match-line stack)))
                (when (and name (s-matches-p r-match-lock name))
                  (let ((ht (make-hash-table :test #'equal)))
                    (puthash addr t ht)

                    (catch 'p-found
                      (while (string-match r-match-line stack pos)
                        (let ((addr (match-string 1 stack)))
                          (if (gethash addr ht)
                              (throw 'p-found t)
                            (puthash addr t ht)
                            (setq pos (match-end 0))))))))))))
    #+end_src
